
{\actuality} В прошлом статический анализ в основном означал ручную проверку 
программ. Сегодня автоматические инструменты статического анализа приобрели 
популярность в индустрии разработки программного обеспечения, они 
значительно увеличивают продуктивность за счет автоматической проверки кода по
широку диапазону критериев. Многие проекты по разработке программного обеспечения 
разрабатываются в соответствии с рекомендациями по кодированию,
таких как MISRA C\cite{Misrac1998}, стремясь к стилю программирования, 
который улучшает ясность и снижает риск появления ошибок. Для проектов с
повышенными требованиями к безопасности соответствие подобным правилам написания
кода настоятельно рекомендуется всеми текущими стандартами безопасности.
Проверка соответствия с помощью инструментов статического анализа является обычной 
практикой.

Однако, для того чтобы предотвратить ошибку одного соотетствия правилам кодирования
не достаточно. Это признано нормой MISRA C через особое правило,
которое рекомендует более глубокий анализ: "Минимизация сбоев во время выполнения 
должна быть обеспечивается использованием хотя бы одного из следующих подходов: 
(a) инструментом статического анализа; (b) инструментами динамического анализа;
(c) явное написание проверок для обработки во время выполнения программы." 
(MISRA C:2004, rule 21.1). Действующие стандарты безопасности требуют демонстрации
отсутствия ошибок времени выполнения и cостояния гонки, например: DO-178B/C, ISO-26262,
EN-50128, IEC-61508.

Неудивительно, что существует множество различных инструментов статического анализа.
Их сравнение и выбор наиболее подходящего инструмента - непростая задача. 
Первая проблема заключается в том, что термин статический анализ используется 
для широкого диапазона техник, которые концептуально сильно различаются.
Их всех объединяет то, что они анализируют код не выполняя его. Их можно
разделить на три большие группы: синтаксические чекеры, не чувствительные к путям 
(unsound) семантические анализаторы, чувствительные к путям (sound ) семантические 
анализаторы. 

Синтаксические чекеры. Ограничиваются исследованием синтаксиса программы. 
Большинство алгоритмически проверяемых правил MISRA C могут быть проверены 
на синтаксическом уровне. В MISRA C:2012, 116 из 143 правил классифицированы 
как разрешимые, что в данном контексте подразумевает возможность проверки 
на синтаксическом уровне. Примеры: Lint? (1978). 

Не чувствительные к путям семантические анализаторы. Сообщают о семантических ошибках 
в программе, таких как ошибки времени выполнения (деления на ноль, арифметические переполнения
или переполнения буфера) и состояния гонки. Могут выдавать false positives
(ложные срабатывания  где нет настоящих дефектов) и false negatives (настоящий дефект, на котором
анализатор не сработал). Примеры: Klocwork\cite{Klocwork}, 
CodeSonar\cite{Codesonar}, Polyspace Bug Finder\cite{Polyspace}
и Coverity\cite{Coverity}.

Чувствительные к путям семантические анализаторы. В основном основаны на абстрактной 
интерпритации, формальном методе анализа программ, который обеспечивает математически
строгий способ доказательства отсутствие дефектов без false negatives: ни один дефект 
не пропущен (из рассматриваемого типа дефектов). Могут сообщать о 
семантических ошибках в программе, включая ошибки времени выполнения и состояния гонки,
также могут использоваться для доказательства функциональных утверждений, например что 
выходные значения всегда будут в ожидаемом диапазоне. False positives могут иметь место. 
Примеры: Astree\cite{Astree},
Frama-C\cite{Frama}, Polyspace Code Prover\cite{Polyspace2prover}, 
AdaCore CodePeer\cite{Codepeer}.

Разницу между этими подходами можно проиллюстрировать на примере деления на 0. В выражении 
"x/0" деление на ноль возможно обнаружить синтаксически, но не в выражении "a/b". "Unsound" анализатор 
может не сообщить о делении на ноль для "a/b" хотя деление на ноль может иметь место в сценариях,
не рассмотренных анализатором. Когда "sound" анализатор не вадает предупреждение о делении на ноль
в "a/b" это доказывает, что b никогда не будет 0. 

Бенчмарки для инструментов статического анализа предоставляет основу для сравнения
различных инструментов. Они должны (как минимум) точно определять, какие дефекты исследуются,
взвешивать серьезность различных дефектов %TODO : reformulate 
брать в расчет глубину анализа (syntactic vs. unsound semantic vs. sound semantic), определять
false positives и false negatives оценки.

В 

%TODO : Continue intro 

% {\progress}
% Этот раздел должен быть отдельным структурным элементом по
% ГОСТ, но он, как правило, включается в описание актуальности
% темы. Нужен он отдельным структурынм элемементом или нет ---
% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aim} данной работы является разработать подход к проверке качества автоматических инструментов анализа программ.

Для~достижения поставленной цели необходимо было решить следующие {\tasks}:
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item Изучить современные инструменты анализа программ : типы, характеристики, техники сравнения.  
  \item Сформулировать требования, критерии и методы, которые позволят ранжировать анализаторы кода
      согласно их сильным и слабым сторонам.
  \item Разработать фреймворк оценки качества анализаторов кода. 
  \item Протестировать полученный фреймворк.
\end{enumerate}


{\novelty}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item Впервые \ldots
  \item Впервые \ldots
  \item Было выполнено оригинальное исследование \ldots
\end{enumerate}

{\influence} \ldots

{\methods} \ldots

{\defpositions}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item Первое положение
  \item Второе положение
  \item Третье положение
  \item Четвертое положение
\end{enumerate}
В папке Documents можно ознакомиться в решением совета из Томского ГУ
в~файле \verb+Def_positions.pdf+, где обоснованно даются рекомендации
по~формулировкам защищаемых положений.

{\reliability} полученных результатов обеспечивается \ldots \ Результаты находятся в соответствии с результатами, полученными другими авторами.


{\probation}
Основные результаты работы докладывались~на:
перечисление основных конференций, симпозиумов и~т.\:п.

{\contribution} Автор принимал активное участие \ldots

\ifnumequal{\value{bibliosel}}{0}
{%%% Встроенная реализация с загрузкой файла через движок bibtex8. (При желании, внутри можно использовать обычные ссылки, наподобие `\cite{vakbib1,vakbib2}`).
    {\publications} Основные результаты по теме диссертации изложены
    в~XX~печатных изданиях,
    X из которых изданы в журналах, рекомендованных ВАК,
    X "--- в тезисах докладов.
}%


